# 玩家角色偏移量

``` cpp

// 可以自己去分析这块内存的数据，包含了（当前玩家的坐标、名字、职业、国家、三国币、五铢、5维属性、基础生命值、当前生命值等等）
typedef struct Charactor
{
    // TODO
};

typedef struct HObject
{
    char padding[38]; // 38 * 4 = 0x98;
    Charactor* playerInfo;
};

typedef struct Overworld
{
    char padding_1[5];
    
};

#define CHARACTOR_STATE 128;
#define MOVE_FORWARD = 0x89;
#define CHARACTOR_NAME 0x8868;
#define LocationX 0x6;
#define LocationY 0x11;

DWORD* GetCharactor()
{
    // 玩家结构首地址= [[[基地址]+0x14]+0x98]
    return (DWORD*)((DWORD*)(GetOverWorld()[0x5]))[0x38];
}

DWORD GetCharactorOf(int index)
{
    return GetCharactor()[index];
}

```

## 获取角色的状态

``` cpp

DWORD state = GetCharactorOf(CHARACTOR_STATE);

// 静止状态
if(state == 0x2)
{

}
// 左右移动状态
if(state == 0x4)
{
   // 人物移动方向的意义: QQ三国游戏存在一个数年都未解决的bug
   // 比如职业为XS的角色，在开启心法期间，使用技能时按住方向键，角色将会在技能动画结束时，朝着方向键所指示的方向移动。
   // 但是此时会触发一个BUG，导致角色移动了一段距离后被拉回到释放技能时的位置。
   // 此bug的机制在于三国允许预输入(即在某个动作期间，可以输入下一个指令，当动作结束后，自动执行指令，且该预输入没有窗口期)
   // 但是QQ三国存在服务器和客户端的双重修正逻辑，即本地客户端A上传移动指令到服务器，当玩家停止移动时，本地客户端A也告知服务器，服务器通过计算移动时长*玩家速度，
   // 得到最终玩家坐标
   // 之后服务端通知所有与客户端A处于同屏的客户端（当然也会通知客户端A）该玩家的坐标。随后所有客户端将更新指定玩家的坐标位置。
   
   // 基于上述的状态同步机制
   // A玩家为XS职业，且开启了心法的状态下
   // 其他同屏玩家作为观察者。
   // A玩家与服务器的延迟为40ms，即0.04s
   // A玩家释放技能攻击目标X->通知服务器（服务端重播攻击场景，将结算出的伤害同步到与玩家A同屏的所有玩家），其中玩家A是在 0.00s发起的指令，服务器在0.04s收到的指令
   // 其他同屏玩家收到了A玩家发起攻击的指令和该指令的伤害结算结果，播放本地动画。
   // A玩家此时在0.9s时预输入移动键，并在1.00s时播放完了技能攻击动画，玩家移动了0.2s后到达坐标(x,y)->服务器在1.02时刻收到了移动指令，服务器校验到目前玩家处于攻击状态，
   // 忽略了此次的移动指令，服务端在0.04s+1s后，同步所有客户端，该玩家释放完技能，并告知需要修正玩家的坐标（此逻辑是在某一年的更新中增加的，为了和谐快攻外挂）
   // 客户端A在1.2s后收到了服务器的回调，将玩家的位置修正为技能释放位置（拉回bug）
   
   // 此bug的原因是服务器做了一些恶行外挂的反作弊校验，导致网络延迟期间，客户端已经完成了动画播放，但服务端的延迟导致忽略了技能释放期间玩家移动的指令。
   
   // 延迟无法避免，即在YY释放80，XS心法释放80/50时，总会拉回。
   // 修复的办法也很简单，就是在客户端刚播放完动画和服务端播放完动画的期间，不断发送移动指令给服务端。直到服务端承认移动指令。
  
   // 参照FIX_ROLLBACK.cpp
   DWORD forward = GetCharactorOf(MOVE_FORWARD);
   if(forward == 0x5)
   {
      // 往左移动
   }
   
   if(forward == 0x3)
   {
      // 右
   }
   
   if(forward == 0x11)
   {
      // 下
   }
   
   if(forward == 0x9)
   {
      // 上
   }
   
   // 0x15:左下
   // 0x13：右下
   // 0xD:左上
   // 0xB 右上
}

// 跳跃状态
if(state == 0x10)
{

}

```
